<?php
/* ====================
[BEGIN_COT_EXT]
Hooks=tools
[END_COT_EXT]
==================== */

/**
 * Menu by Parent Category for CMF Cotonti Siena v.0.9.26, PHP v.8.4+, MySQL v.8.0
 * Filename: plugins/menubyparentcat/menubyparentcat.tools.php
 * Purpose:  the menubyparentcat plugin in the Cotonti admin panel.
 * Date: 2025-11-27
 * @package menubyparentcat
 * @version 2.2.8
 * @author webitproff
 * @copyright Copyright (c) webitproff 2025 https://github.com/webitproff/cot-menubyparentcat
 * @license BSD
 */

// Этот файл — основной административный интерфейс плагина. Он подключается через хук tools и открывает страницу управления меню в разделе «Другое → Меню по родительской категории». Всё, что вы видите в админке при работе с плагином, рендерится именно отсюда. Здесь собраны формы добавления/редактирования, список элементов и вся логика сохранения/удаления.

defined('COT_CODE') or die('Wrong URL.');
// Стандартная защита Cotonti: если скрипт выполняется только при легитимном входе через index.php. Прямой вызов по URL сразу завершит работу с сообщением Wrong URL. Это предотвращает несанкционированный доступ к коду плагина.

require_once cot_incfile('forms');
// Подключаем вспомогательные функции для генерации HTML-форм (cot_selectbox, cot_checkbox и т.д.). Без этого файла невозможно красиво и безопасно выводить селекты и чекбоксы в админке.

require_once cot_incfile('menubyparentcat', 'plug');
// Подключаем основной файл плагина (обычно menubyparentcat.php), где лежат общие функции, константы и, возможно, дополнительные обработчики. Это нужно, чтобы внутри tools.php можно было использовать функции плагина.

require_once cot_langfile('menubyparentcat', 'plug');
// Загружаем языковой файл плагина (ru.lang.php и т.п.). Благодаря этому в шаблонах и сообщениях можно использовать $L['menubyparentcat_add'], $L['Edit'] и т.д. вместо жёстко прописанных русских строк.

require_once cot_incfile('page', 'module');
// Подключаем модуль страниц — нам понадобятся таблицы cot_pages, функции работы со структурой и т.д. Без этого плагин не сможет получать заголовки страниц и проверять их существование.

require_once cot_incfile('structure', 'core');
// Подключаем ядро работы со структурой категорий. Переменная $structure['page'] заполняется именно здесь. Без неё мы не сможем построить дерево дочерних категорий и вычислить отступы.

global $db_pages, $db_menubyparentcat_items;
// Делаем глобальными названия таблиц, чтобы дальше писать коротко $db_pages вместо Cot::$db->pages. Во многих старых плагинах это до сих пор используется, хотя сейчас предпочтительнее Cot::$db->pages.

Cot::$db->registerTable('menubyparentcat_items');
// Регистрируем свою таблицу в системе Cotonti, чтобы в дальнейшем можно было использовать короткое имя $db_menubyparentcat_items вместо полного префикса. Также это даёт защиту от SQL-инъекций при использовании встроенных методов.

cot_block(Cot::$usr['isadmin']);
// Жёстко блокируем доступ всем, кроме администраторов. Если обычный пользователь или гость попытается открыть эту страницу — получит ошибку 403 или редирект на главную. Безопасность превыше всего.

$code_parentcat = Cot::$cfg['plugin']['menubyparentcat']['code_parentcat'] ?? '';
// Получаем из настроек плагина код основной родительской категории (например, user-guide или docs). Оператор ?? появился в PHP 7+, поэтому плагин требует минимум PHP 8.4 — всё безопасно.

if (empty($code_parentcat) || empty($structure['page'][$code_parentcat])) {
    cot_die("Ошибка: категория «{$code_parentcat}» не найдена или не указана в настройках плагина.");
}
// Критическая проверка: если в настройках плагина не указан код категории или такой категории не существует в структуре — сразу убиваем скрипт с понятным сообщением. Это спасает от белого экрана смерти и даёт админу понять, что нужно зайти в Настройки → Плагины → Menu by Parent Category и указать правильный код.

$t = new XTemplate(cot_tplfile('menubyparentcat.admin', 'plug'));
// Создаём объект шаблонизатора XTemplate и подгружаем файл templates/menubyparentcat.admin.tpl. Весь HTML-интерфейс админки будет собираться через $t->assign() и $t->parse(). Это стандартный и самый быстрый способ в Cotonti.

$action = cot_import('a', 'G', 'ALP');
// Получаем параметр a из GET (add, edit, delete). ALP = alphanumeric + подчёркивание, фильтруем, чтобы никто не подсунул что-то левое.

$id = cot_import('id', 'G', 'INT');
// Получаем числовой ID записи для редактирования или удаления. Если параметр не числовой — будет 0, что безопасно для дальнейших запросов.

/* === 1. Дочерние категории (с отступами) === */
// Блок сбора всех дочерних категорий указанной родительской категории с учётом вложенности. Нужно для селекта «Добавить категорию-разделитель».

$all_child_codes = cot_structure_children('page', $code_parentcat, false, true);
// Ключевая функция Cotonti: возвращает плоский массив кодов всех потомков $code_parentcat (включая всех-всех-всех внуков). 
// Параметр false — не включать саму родительскую категорию, true — рекурсивно искать на любую глубину.

$child_options = [];
// Инициализируем массив, который потом пойдёт в cot_selectbox: ключ — код категории, значение — человекочитаемый заголовок с отступами.

$base_path = $structure['page'][$code_parentcat]['path'] ?? '';
// Берём «точечный» путь родительской категории (например, docs.user-guide). Он нужен, чтобы посчитать базовый уровень вложенности.

$base_level = substr_count($base_path, '.');
// Считаем количество точек в пути — это уровень вложенности родителя. Например, если путь docs.user-guide — будет 1 точка → уровень 1.

foreach ($all_child_codes as $code) {
    if ($code === $code_parentcat || !isset($structure['page'][$code])) continue;
    // Пропускаем саму родительскую категорию (на всякий случай) и несуществующие коды (защита от битых данных в структуре).

    $title = $structure['page'][$code]['title'];
    // Берём человекочитаемое название категории из структуры.

    $path  = $structure['page'][$code]['path'];
    // Полный точечный путь текущей дочерней категории (например, docs.user-guide.projects-manual).

    $level = substr_count($path, '.') - $base_level;
    // Вычисляем относительный уровень вложенности: сколько точек сверх базового уровня. Это нужно для красивых отступов ——— Чем глубже, тем больше тире.

    $indent = str_repeat('— ', max(0, $level));
    // Формируем визуальные отступы: за каждый уровень вложенности добавляем «— » (тире + пробел). max(0,…) защищает от отрицательного значения на случай ошибок.

    $child_options[$code] = $indent . $title . ' (' . $code . ')';
    // Формируем финальную строку для селекта: отступ + название + (код в скобках). Админу сразу видно и иерархию, и точный код категории.
}

/* === 2. Страницы из дочерних категорий === */
// Теперь собираем все опубликованные страницы, которые лежат в любой из дочерних категорий. Нужно для селекта «Добавить страницу».

$allpages = [];
// Инициализируем массив страниц.

if (!empty($all_child_codes)) {
    // Если есть хотя бы одна дочерняя категория — идём в базу.

    $placeholders = implode(',', array_fill(0, count($all_child_codes), '?'));
    // Безопасно создаём строку вроде ?,?,? в зависимости от количества категорий. Это для подготовленного запроса.

    $allpages = Cot::$db->query(
        "SELECT page_id, page_title, page_cat FROM $db_pages
         WHERE page_cat IN ($placeholders) AND page_state = 0
         ORDER BY page_title",
        $all_child_codes
    )->fetchAll();
    // Один запрос получает все опубликованные страницы (page_state=0) из всех дочерних категорий, сразу сортируя по названию. 
    // Это быстро даже при сотнях страниц, потому что используется индекс по page_cat и page_state.
}


/* === POST — добавление / редактирование === */
// Основной блок обработки формы: сюда попадаем только когда админ нажал «Добавить» или «Сохранить». 
// Работает и для новых элементов (a=add), и для редактирования существующих (a=edit).

if ($_SERVER['REQUEST_METHOD'] === 'POST' && in_array($action, ['add', 'edit'])) {
    // Проверяем, что запрос действительно POST и действие — одно из разрешённых. 
    // Это защита от случайного GET-вызова с параметром a=add и от подделки действия.

    cot_check_xp();
    // Проверка защиты от повторной отправки формы (anti-xpost). 
    // Cotonti автоматически ставит скрытое поле x в каждую форму — если его нет или он старый, выполнение прервётся.

    $item_type = cot_import('item_type', 'P', 'ALP');
    $item_type = ($item_type === 'cat') ? 'cat' : 'page';
    // Принимаем тип элемента из формы (cat или page). 
    // Даже если кто-то подменит значение — мы принудительно приведём всё к одному из двух разрешённых вариантов.

    $data = [
        'mbpcat_parent_cat'       => $code_parentcat,
        // Жёстко прописываем код родительской категории из настроек плагина. 
        // Пользователь не может его изменить — это гарантирует, что все элементы меню принадлежат только одной корневой категории.

        'mbpcat_item_type'        => $item_type,
        // Тип элемента: либо категория-разделитель, либо ссылка на страницу.

        'mbpcat_item_code_cat'    => null,
        'mbpcat_item_page_cat'    => null,
        'mbpcat_item_page_id'     => null,
        // Обнуляем поля, которые относятся к другому типу элемента. 
        // Это важно для чистоты данных: у категории не должно быть page_id и наоборот.

        'mbpcat_title_override'   => cot_import('title_override', 'P', 'TXT'),
        // Переопределённый заголовок, который будет показан в меню вместо стандартного. 
        // Если поле пустое — дальше будет браться заголовок из структуры или страницы.

        'mbpcat_include'          => cot_import('include', 'P', 'BOL') ? 1 : 0,
        // Чекбокс «Показывать в меню». cot_import с типом BOL возвращает true/false, превращаем в 1/0 для записи в БД.

        'mbpcat_sortorder_cat'    => 0,
        'mbpcat_sortorder_pageincat' => 0,
        // Изначально порядок нулевой — потом переопределим только нужный в зависимости от типа элемента.
    ];

    if ($item_type === 'cat') {
        // Случай, когда добавляем/редактируем категорию-разделитель.

        $data['mbpcat_item_code_cat'] = cot_import('item_code_cat', 'P', 'TXT');
        // Код дочерней категории (например, projects-manual), который будет отображаться как заголовок-разделитель.

        $data['mbpcat_sortorder_cat'] = (int)cot_import('sortorder', 'P', 'INT');
        // Порядок сортировки среди других категорий-разделителей. 
        // Чем меньше число — тем выше в меню. При одинаковых значениях порядок будет по mbpcat_id.
    } else {
        // Случай, когда добавляем/редактируем конкретную страницу.

        $page_id = (int)cot_import('item_code_page', 'P', 'INT');
        // Получаем ID страницы из селекта.

        $page = Cot::$db->query("SELECT page_cat FROM $db_pages WHERE page_id = ? LIMIT 1", [$page_id])->fetch();
        // Делаем отдельный запрос, чтобы убедиться, что страница существует и узнать её реальную категорию. 
        // Это важно, потому что пользователь мог переместить страницу в другую категорию после загрузки формы.

        if ($page) {
            $data['mbpcat_item_page_cat'] = $page['page_cat'];     // ← всегда правильная категория
            // Записываем актуальную категорию страницы — даже если админ её поменял, у нас будет верное значение.

            $data['mbpcat_item_page_id']  = $page_id;
            // Сохраняем ID страницы.

            $data['mbpcat_sortorder_pageincat'] = (int)cot_import('sortorder', 'P', 'INT');
            // Порядок страницы внутри своей категории. 
            // Работает независимо от глобального порядка страниц в Cotonti — только для этого меню.
        } else {
            cot_error('Страница не найдена');
            // Если страница удалена или ID битый — показываем ошибку, дальше сохранение не пойдёт.
        }
    }

    if (($item_type === 'cat' && empty($data['mbpcat_item_code_cat'])) ||
        ($item_type === 'page' && empty($data['mbpcat_item_page_id']))) {
        cot_error('Выберите элемент');
        // Финальная защита от пустого выбора. 
        // Даже если JavaScript отключён или кто-то ковыряет форму вручную — без выбора элемента ничего не сохранится.
    } else {
        // Всё проверено — сохраняем.

        if ($action === 'add') {
            Cot::$db->insert($db_menubyparentcat_items, $data);
            cot_message('Элемент добавлен');
            // Добавляем новую запись в таблицу меню.
        } else {
            Cot::$db->update($db_menubyparentcat_items, $data, 'mbpcat_id = ?', [$id]);
            cot_message('Изменения сохранены');
            // Обновляем существующую запись. Условие по mbpcat_id, передаём подготовленный параметр.
        }
        cot_redirect(cot_url('admin', 'm=other&p=menubyparentcat', '', true));
        // После успешного сохранения — редирект на чистый URL без параметров a=add/edit, 
        // чтобы при обновлении страницы не было повторной отправки формы.
    }
}
/* === УДАЛЕНИЕ ЭЛЕМЕНТА МЕНЮ === */
// Этот блок срабатывает только при переходе по ссылке вида: admin.php?m=other&p=menubyparentcat&a=delete&id=7&x=abc123

if ($action === 'delete' && $id > 0) {
    // Проверяем одновременно два условия: параметр a должен быть строго 'delete' и id должен быть положительным целым числом. 
    // Это первая линия защиты от случайного или злонамеренного вызова удаления без нужных параметров.

    cot_check_xg();
    // Критически важная защита от CSRF-атак. Функция проверяет наличие и актуальность одноразового токена "x", 
    // который Cotonti автоматически добавляет ко всем опасным ссылкам через cot_xg(). Без правильного токена — выполнение прерывается с ошибкой 403.

    Cot::$db->delete($db_menubyparentcat_items, 'mbpcat_id = ?', [$id]);
    // Выполняется безопасное удаление ровно одной записи из таблицы cot_menubyparentcat_items по первичному ключу. 
    // Используется подготовленный запрос с плейсхолдером ?, поэтому даже если $id подменят — SQL-инъекция невозможна.

    cot_message('Элемент удалён');
    // Добавляем в сессию сообщение об успешном действии. 
    // Оно будет выведено зелёным блоком вверху админки после редиректа благодаря cot_display_messages().

    cot_redirect(cot_url('admin', 'm=other&p=menubyparentcat', '', true));
    // Принудительный редирект на чистую страницу плагина без GET-параметров. 
    // Это реализация Post/Redirect/Get (PRG) паттерна — защищает от повторного удаления при обновлении страницы (F5).
}

/* === ПОДГОТОВКА ЗНАЧЕНИЙ ДЛЯ ФОРМЫ ДОБАВЛЕНИЯ/РЕДАКТИРОВАНИЯ === */
// Создаём массив с дефолтными значениями полей формы. Он будет использоваться и при добавлении, и при редактировании.

$form_values = [
    // Массив-шаблон, который потом частично или полностью перезапишется реальными данными при редактировании записи.
    'mbpcat_id'                  => 0,
    // ID записи в таблице. При добавлении нового элемента = 0, при редактировании — реальный ID из БД.

    'mbpcat_item_type'           => 'page',
    // По умолчанию считаем, что админ хочет добавить именно страницу, а не категорию-разделитель. Удобнее для большинства случаев.

    'mbpcat_item_code_cat'       => '',
    // Код категории (для типа cat). При добавлении пусто, при редактировании категории будет заполнено.

    'mbpcat_item_page_id'        => 0,
    // ID страницы из cot_pages. При добавлении = 0, при редактировании страницы будет реальный ID.

    'mbpcat_title_override'      => '',
    // Пользовательское название в меню. Если пусто — берётся из структуры или страницы автоматически.

    'mbpcat_include'             => 1,
    // По умолчанию новый элемент сразу включён в меню (показывается). Удобно — не нужно каждый раз ставить галочку.

    'mbpcat_sortorder_cat'       => 0,
    // Порядок сортировки среди категорий-разделителей. 0 = будет в конце списка категорий.

    'mbpcat_sortorder_pageincat' => 0,
    // Порядок сортировки страниц внутри своей категории. 0 = в конце списка страниц в этой категории.
];
// Закрывающая скобка массива дефолтных значений формы.

$is_edit = ($action === 'edit' && $id > 0);
// Булева переменная: true — мы сейчас в режиме редактирования существующей записи, false — добавляем новую.

if ($is_edit) {
    // Если зашли по ссылке ?a=edit&id=7 — пытаемся загрузить существующую запись из базы.

    $row = Cot::$db->query("SELECT * FROM $db_menubyparentcat_items WHERE mbpcat_id = ?", [$id])->fetch();
    // Делаем запрос только по первичному ключу — быстро и безопасно. Возвращает одну строку или false.

    if ($row && $row['mbpcat_parent_cat'] === $code_parentcat) {
        // Дополнительная проверка безопасности: убеждаемся, что запись действительно принадлежит текущей родительской категории.
        // Защищает от ситуации, когда админ вручную подменит id на запись из другого меню (если у него несколько меню через разные parent_cat).

        $form_values = $row;
        // Перезаписываем весь массив $form_values реальными данными из базы — все поля формы автоматически заполнятся.
    }
    // Если запись не найдена или принадлежит другому меню — $form_values остаётся с дефолтными значениями, форма будет пустая.
}

/* === ГЕНЕРАЦИЯ ВЫПАДАЮЩИХ СПИСКОВ === */

$select_cat = cot_selectbox(
    ($form_values['mbpcat_item_type'] === 'cat') ? $form_values['mbpcat_item_code_cat'] : '',
    'item_code_cat',
    array_keys($child_options),
    array_values($child_options),
    false,
    ['class' => 'form-select']
);
// Создаём HTML-<select name="item_code_cat"> для выбора категории-разделителя. 
// Если сейчас редактируем элемент типа cat — автоматически подсвечивается нужный <option value="projects-manual">.

$page_options = [];
// Инициализируем пустой массив, который будет содержать варианты для селекта страниц.

foreach ($allpages as $p) {
    // Перебираем все опубликованные страницы из дочерних категорий, собранные ранее.

    $cat_title = $structure['page'][$p['page_cat']]['title'] ?? $p['page_cat'];
    // Пытаемся взять человекочитаемое название категории страницы. Если по какой-то причине его нет — просто код.

    $page_options[$p['page_id']] = htmlspecialchars($p['page_title'] ?: 'Без названия') . " [{$cat_title}]";
    // Формируем строку вида: "Как разместить задание? [Задания, работа]" — админу сразу видно, где лежит страница.
}
// Конец цикла формирования вариантов для селекта страниц.

$select_page = cot_selectbox(
    ($form_values['mbpcat_item_type'] === 'page') ? $form_values['mbpcat_item_page_id'] : 0,
    'item_code_page',
    array_keys($page_options),
    array_values($page_options),
    false,
    ['class' => 'form-select']
);
// Генерируем второй <select name="item_code_page">. При редактировании страницы нужный вариант будет выбран автоматически.

/* === ВЫВОД СПИСКА ВСЕХ ЭЛЕМЕНТОВ МЕНЮ === */

$items = Cot::$db->query(
    "SELECT * FROM $db_menubyparentcat_items 
     WHERE mbpcat_parent_cat = ? 
     ORDER BY mbpcat_sortorder_cat ASC, mbpcat_sortorder_pageincat ASC",
    [$code_parentcat]
)->fetchAll();
// Один эффективный запрос получает ВСЕ элементы текущего меню в правильном порядке: 
// сначала сортируются категории по mbpcat_sortorder_cat, потом внутри каждой — страницы по mbpcat_sortorder_pageincat.

foreach ($items as $row) {
    // Перебираем каждую запись из таблицы и готовим данные для вывода в таблице.

    if ($row['mbpcat_item_type'] === 'cat') {
        // Обработка отображения категории-разделителя

        $title = $row['mbpcat_title_override']
            ?: ($structure['page'][$row['mbpcat_item_code_cat']]['title'] ?? $row['mbpcat_item_code_cat']);
        // Если админ задал свой заголовок — используем его. Иначе — название из структуры, иначе — просто код.

        $code_display = $row['mbpcat_item_code_cat'];
        // В колонке «Код» показываем только код категории (например, projects-manual)
    } else {
        // Обработка отображения ссылки на страницу

        $page_title = Cot::$db->query("SELECT page_title FROM $db_pages WHERE page_id = ? LIMIT 1", [$row['mbpcat_item_page_id']])->fetchColumn();
        // Делаем отдельный запрос, чтобы получить актуальное название страницы (вдруг его поменяли после добавления в меню).

        $title = $row['mbpcat_title_override'] ?: ($page_title ?: 'Страница #' . $row['mbpcat_item_page_id']);
        // Приоритет: 1) ручной заголовок → 2) текущее название страницы → 3) заглушка с ID

        $code_display = $row['mbpcat_item_page_id'] . ' → ' . $row['mbpcat_item_page_cat'];
        // В колонке «Код» показываем: 15 → services-manual — сразу видно ID и категорию
    }

    $t->assign([
        // Начинаем передачу данных конкретной строки меню в шаблон XTemplate.
        // Все переменные ниже будут доступны внутри блока {ITEM_ROW} в файле menubyparentcat.admin.tpl

        'ITEM_ID'         => $row['mbpcat_id'],
        // Передаём числовой идентификатор записи в таблице cot_menubyparentcat_items.
        // Используется в шаблоне для формирования ссылок редактирования/удаления и как уникальный ключ строки.

        'ITEM_TYPE'       => $row['mbpcat_item_type'] === 'cat' ? 'Категория' : 'Страница',
        // Человекочитаемый тип элемента. Если mbpcat_item_type = 'cat' — выводим слово "Категория (это заголовок-разделитель),
        // иначе — Страница (активная ссылка на статью). Нужно для колонки "Тип" в таблице админки.

        'ITEM_CODE'       => htmlspecialchars($code_display),
        // Выводим в колонке "Код" либо код категории (projects-manual), либо "15 to services-manual".
        // htmlspecialchars обязателен — защищает от XSS, если в коде категории или заголовке страницы вдруг окажется HTML/JS.

        'ITEM_TITLE'      => htmlspecialchars($title),
        // Финальное название, которое увидит пользователь в меню.
        // Берётся из mbpcat_title_override, либо из структуры, либо из cot_pages. htmlspecialchars — защита от инъекций через заголовки.

        'ITEM_INCLUDE'    => $row['mbpcat_include'] ? 'Да' : 'Нет',
        // Показывать/скрывать элемент в публичном меню. 1 = Да (элемент виден на сайте), 0 = Нет (скрыт).
        // В админке выводится просто текстом "Да"/"Нет" для наглядности.

        'ITEM_SORTORDER'  => $row['mbpcat_item_type'] === 'cat' ? $row['mbpcat_sortorder_cat'] : $row['mbpcat_sortorder_pageincat'],
        // Показываем текущее значение порядка сортировки.
        // Если это категория — берём mbpcat_sortorder_cat (порядок среди разделителей),
        // если страница — mbpcat_sortorder_pageincat (порядок внутри своей категории).

        'ITEM_EDIT_URL'   => cot_url('admin', "m=other&p=menubyparentcat&a=edit&id={$row['mbpcat_id']}&" . cot_xg()),
        // Полная ссылка на редактирование именно этой записи.
        // cot_xg() добавляет свежий одноразовый токен x=... для защиты от CSRF при переходе на форму редактирования.

        'ITEM_DELETE_URL' => cot_url('admin', "m=other&p=menubyparentcat&a=delete&id={$row['mbpcat_id']}&" . cot_xg()),
        // Полная ссылка на удаление именно этой записи.
        // Также содержит свежий токен cot_xg(), без которого удаление не пройдёт (защита от поддельных запросов).
    ]);
    // Закрывающая скобка массива assign. После этой строки все перечисленные выше переменные становятся доступны в текущем цикле шаблона.

    $t->parse('MAIN.ITEM_ROW');
    // Парсим один проход блока MAIN.ITEM_ROW в шаблоне.
    // Каждый вызов добавляет в вывод одну строку таблицы с данными текущего $row.
    // После завершения цикла foreach у нас будет полностью готовая таблица со всеми элементами меню.
    // Передаём все данные одной строки в шаблон. cot_xg() добавляет свежий анти-CSRF токен к ссылкам.
    // Парсим одну строку таблицы (блок ITEM_ROW в шаблоне menubyparentcat.admin.tpl)
}

/* === ФИНАЛЬНАЯ ПЕРЕДАЧА ПЕРЕМЕННЫХ В ШАБЛОН === */

$t->assign([
    'PAGE_TITLE'       => 'Меню: ' . ($structure['page'][$code_parentcat]['title'] ?? $code_parentcat),
    // Заголовок страницы в админке: «Меню: Руководство пользователя» или просто код, если название не найдено.

    'EDIT_CAT_SELECT'  => $select_cat,
    // Готовый HTML-код селекта категорий

    'EDIT_PAGE_SELECT' => $select_page,
    // Готовый HTML-код селекта страниц

    'EDIT_TITLE'       => htmlspecialchars($form_values['mbpcat_title_override'] ?? ''),
    // Значение поля «Переопределить заголовок»

    'EDIT_SORTORDER'   => $form_values['mbpcat_item_type'] === 'cat' ? $form_values['mbpcat_sortorder_cat'] : $form_values['mbpcat_sortorder_pageincat'],
    // Правильное значение поля сортировки в зависимости от типа элемента

    'EDIT_INCLUDE'     => $form_values['mbpcat_include'] ? 'checked' : '',
    // Атрибут checked для чекбокса «Показывать»

    'EDIT_TYPE_CAT'    => $form_values['mbpcat_item_type'] === 'cat' ? 'selected' : '',
    // selected для радиокнопки/селекта типа «Категория»

    'EDIT_TYPE_PAGE'   => $form_values['mbpcat_item_type'] === 'page' ? 'selected' : '',
    // selected для типа «Страница»

    'FORM_ACTION'      => $is_edit
        ? cot_url('admin', "m=other&p=menubyparentcat&a=edit&id={$form_values['mbpcat_id']}")
        : cot_url('admin', 'm=other&p=menubyparentcat&a=add'),
    // URL формы: при редактировании содержит &a=edit&id=7, при добавлении — только &a=add

    'FORM_HEADER'      => $is_edit ? $L['menubyparentcat_edit'] : $L['menubyparentcat_add'],
    // Текст заголовка формы: «Редактировать элемент» или «Добавить элемент»

    'FORM_SUBMIT'      => $is_edit ? $L['menubyparentcat_save'] : $L['menubyparentcat_add'],
    // Текст кнопки: «Сохранить изменения» или «Добавить»

    'FORM_TYPE_COLOR'  => $is_edit ? 'warning' : 'success',
    // Цвет кнопки: жёлтая при редактировании, зелёная при добавлении

    'CANCEL_URL'       => cot_url('admin', 'm=other&p=menubyparentcat'),
    // Ссылка «Отмена» — возвращает на список без параметров
]);

$t->parse('MAIN.ITEM_FORM');
// Парсим блок формы добавления/редактирования — он находится над таблицей и всегда один.

cot_display_messages($t);
// Выводим все сообщения об успехе/ошибке (cot_message(), cot_error()) в стандартный блок уведомлений админки.
// подключаемый в menubyparentcat.admin.tpl файл шаблона {FILE "{PHP.cfg.themes_dir}/admin/{PHP.cfg.admintheme}/warnings.tpl"}

$t->parse('MAIN');
// Финальный парсинг всего шаблона — собираем полностью готовый HTML.

$adminMain = $t->text('MAIN');
// Переменная $adminMain — это то, что Cotonti выведет в центральной части админ-панели. 
// Всё содержимое шаблона menubyparentcat.admin.tpl теперь в этой строке.